#!/usr/bin/env python3
# -*- coding: utf8 -*-

from __future__ import print_function
from __future__ import unicode_literals

# todo: locking to prevent multiple instances of mail_update

import sys
import os
import traceback
import argparse
import time
import subprocess
import shutil
import glob
from os.path import exists

from multiprocessing import Process     #https://docs.python.org/3/library/multiprocessing.html
from multiprocessing import Queue
from multiprocessing import Pool
from multiprocessing import cpu_count

global debug
debug = False


def cprint(*args, **kwargs):
    caller = sys._getframe(1).f_code.co_name
    print(str("%.5f" % time.time()), os.getpid(), '{0: <39}'.format(caller+'()'), *args, file=sys.stderr, **kwargs)


def is_zero_length_file(fpath):
    if os.path.isfile(fpath):
        if os.path.getsize(fpath) == 0:
            return True
    return False


def file_exists(file):
    if os.path.isfile(file): #unlike os.path.exists(False), os.path.isfile(False) returns False so no need to call path_exists() first.
        return True
    return False


def count_files(folder):
    total = 0
    for root, dirs, files in os.walk(folder):
        total += len(files)
    return total


def list_files(folder):
    all_files = []
    total = 0
    for root, dirs, files in os.walk(folder):
        for file in files:
            relative_file_path = root + b'/' + file
            all_files.append(relative_file_path)
    return set(all_files)


def folder_exists(path):
    cprint("folder_exists():", path)
    if os.path.isdir(path): #unlike os.path.exists(False), os.path.isdir(False) returns False so no need to call path_exists() first.
        return True
    return False


def create_folder(folder):
    try:
        os.makedirs(folder)
        return True
    except Exception as e:
        cprint(e)
        cprint("Something went wrong making the folder:", folder, "Exiting.")
        os._exit(1)


def check_or_create_folder(folder):
    if not os.path.isdir(folder):
        make_folder_answer = input(b"The folder " + folder + b" does not exist. This is not normal. Type yes to create it and continue, otherwise exiting here.: ")
        if make_folder_answer.lower() != "yes":
            cprint("Exiting before mkdir.")
            os._exit(1)
        else:
            create_folder(folder)
            return True


def check_for_notmuch_database():
    notmuch_database_folder = email_archive_folder + b"/_Maildirs/.notmuch/xapian"
    if not os.path.isdir(notmuch_database_folder):
        cprint('''Error: notmuch has not created the xapian database yet. Run \"mail_update user@domain.com --update\" first. Exiting.''')
        os._exit(1)


def rsync_mail():
    load_ssh_key()

    rsync_p = subprocess.Popen([b'rsync', b'--ignore-existing', b'--size-only', b'-t', b'--whole-file', b'-L', b'-c', b'--stats', b'-i', b'-r', b'-vv', email_address + b':gpgMaildir', gpgMaildir_archive_folder + b'/'], stdout=subprocess.PIPE)
    rsync_p_output = rsync_p.communicate()
    for line in rsync_p_output[0].split(b'\n'):
#       cprint(line.decode('utf-8'))
        if b'exists' not in line:
            cprint(line)

    cprint("rsync_p.returncode:", rsync_p.returncode)
    if rsync_p.returncode != 0:
        cprint("rsync did not return 0, exiting")
#        os._exit(1)

    with open(b"/dev/shm/.gpgmda_rsync_last_new_mail_" + email_address, 'wb') as rsync_logfile_handle:
        rsync_logfile_handle.write(rsync_p_output[0])


def run_notmuch(mode, query=b"", debug=False):
    if debug: cprint("run_notmuch():", mode)
    if not isinstance(query, bytes):
        query = bytes(query, encoding='UTF8')

    notmuch_config_folder = email_archive_folder + b"/_notmuch_config"
    check_or_create_folder(notmuch_config_folder)

    notmuch_config_file = notmuch_config_folder + b"/.notmuch_config"
    make_notmuch_config()

    if mode == "update_notmuch_db":

        current_env = os.environ.copy()
        current_env["NOTMUCH_CONFIG"] = notmuch_config_file
        notmuch_p = subprocess.Popen([b'notmuch', b'new'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False, env=current_env)
        cprint(notmuch_p.args)
        notmuch_p_output = notmuch_p.communicate()

        cprint("notmuch_p_output:")
        cprint(notmuch_p_output)

        cprint("notmuch_p_output[0]:")
        for line in notmuch_p_output[0].split(b'\n'):
            cprint(line.decode('utf-8'))

        cprint("notmuch_p_output[1]:")
        for line in notmuch_p_output[1].split(b'\n'):
            cprint(line.decode('utf-8'))
            if b"Note: Ignoring non-mail file:" in line:
                non_mail_file = line.split(b" ")[-1]
                cprint("found file that gmime does not like:", non_mail_file)
                random_id = non_mail_file[-40:]
                cprint("random_id:", random_id)
                maildir_subfolder = non_mail_file.split(b'/')[-2]
                cprint("maildir_subfolder:", maildir_subfolder)
                encrypted_file = gpgmaildir + b'/' + maildir_subfolder + b'/' + random_id
                cprint("encrypted_file:", encrypted_file)
                cprint("head -c 500:")
                command = b"head -c 500 " + non_mail_file
                os.system(command)
                cprint("running nano")
                command = b"nano " + non_mail_file
                os.system(command)

                delete_message_answer = input("Would you like to move this message locally to the ~/.gpgmda/non-mail folder and delete it on the server? (yes/no/skipall): ")

                if delete_message_answer.lower() == "skipall":
                    break

                if delete_message_answer.lower() == "yes":
                    non_mail_path = b'~/.gpgmda/non-mail'

                    os.path.sep = b'/'      #py3: paths _are_ bytes. glob.glob(b'/home') does it right
                    os.path.altsep = b'/'

                    os.makedirs(os.path.expanduser(non_mail_path), exist_ok=True)

                    cprint("Processing files for local move and delete:")

                    cprint(non_mail_file)
                    shutil.move(non_mail_file, os.path.expanduser(non_mail_path))

                    cprint(encrypted_file)
                    shutil.move(encrypted_file, os.path.expanduser(non_mail_path))

                    if maildir_subfolder == b".sent":
                        target_file = b"/home/sentuser/gpgMaildir/new/" + random_id
                        command = b"ssh root@v6y.net rm -v " + target_file
                        cprint(command)
                        os.system(command)

                    elif maildir_subfolder == b"new":
                        target_file = b"/home/user/gpgMaildir/new/" + random_id
                        command = b"ssh root@v6y.net rm -v " + target_file    #todo use ~/.gpgmda/config
                        cprint(command)
                        os.system(command)

                    else:
                        cprint("unknown exception, exiting")
                        os._exit(1)

        cprint("notmuch_p.returncode:", notmuch_p.returncode)
        if notmuch_p.returncode != 0:
            cprint("notmuch new did not return 0, exiting")
            os._exit(1)

    elif mode == "query_notmuch":
        check_for_notmuch_database()
        command = b"NOTMUCH_CONFIG=" + notmuch_config_file + b" notmuch " + query
        cprint("command:", command)
        return_code = os.system(command)
        if return_code != 0:
            cprint("\"notmuch " + query + "\" returned nonzero, exiting")
            os._exit(1)

    elif mode == "query_address_db":
        check_for_notmuch_database()
        command = b"XDG_CONFIG_HOME=" + notmuch_config_folder + b" NOTMUCH_CONFIG=" + notmuch_config_file + b" " + gpgmda_program_folder + b"/nottoomuch-addresses.sh " + query
        return_code = os.system(command)
        if return_code != 0:
            cprint("\"nottoomuch-addresses.sh\" returned nonzero, exiting")
            os._exit(1)

    elif mode == "build_address_db":
        check_for_notmuch_database()
        command = b"XDG_CONFIG_HOME=" + notmuch_config_folder + b" NOTMUCH_CONFIG=" + notmuch_config_file + b" " + gpgmda_program_folder + b"/nottoomuch-addresses.sh --update --rebuild"
        return_code = os.system(command)
        if return_code != 0:
            cprint("\"nottoomuch-addresses.sh\" returned nonzero, exiting")
            os._exit(1)

    elif mode == "update_address_db":
        check_for_notmuch_database()
        command = b"XDG_CONFIG_HOME=" + notmuch_config_folder + b" NOTMUCH_CONFIG=" + notmuch_config_file + b" " + gpgmda_program_folder + b"/nottoomuch-addresses.sh --update"
        return_code = os.system(command)
        if return_code != 0:
            cprint("\"nottoomuch-addresses.sh\" returned nonzero, exiting")
            os._exit(1)

    else:
        cprint("invalid mode", mode, "exiting.")
        os._exit(1)


def make_notmuch_config():
    username = email_address.split(b"@")[0]

    notmuch_config = b"""
[database]
path = """ + email_archive_folder + b"""/_Maildirs

[user]
name = """ + username + b"""
primary_email=""" + email_address + b"""

[new]
tags = unread;inbox;

[maildir]
synchronize_flags = false
"""
    notmuch_config_folder = email_archive_folder + b"/_notmuch_config"
    check_or_create_folder(notmuch_config_folder)
    notmuch_config_file_location = notmuch_config_folder + b"/.notmuch_config"
    if debug: cprint("writing notmuch config to:", notmuch_config_file_location)
    notmuch_config_file_handle = open(notmuch_config_file_location, "wb")
    notmuch_config_file_handle.write(notmuch_config)
    notmuch_config_file_handle.close()


def move_terminal_text_up_one_page():
    cprint("moving terminal text up one page")
    tput_p = subprocess.Popen(['tput', 'lines'], stdout=subprocess.PIPE)
    tput_p_output = tput_p.communicate()
    tput_p_output = tput_p_output[0].decode('utf8').strip()

    for line in range(int(tput_p_output)):
        print('', file=sys.stderr)


def start_alot():
    check_for_notmuch_database()
    alot_config = subprocess.Popen([gpgmda_program_folder + b"/make_alot_config", email_address], stdout=subprocess.PIPE).communicate()
    alot_theme = subprocess.Popen([gpgmda_program_folder + b"/make_alot_theme"], stdout=subprocess.PIPE).communicate()

    alot_config_f = open(b'/dev/shm/__alot_config_' + email_address, 'wb')
    alot_theme_f = open(b'/dev/shm/__alot_theme_' + email_address, 'wb')

    alot_config_f.write(alot_config[0])
    alot_theme_f.write(alot_theme[0])

    alot_config_f.close()
    alot_theme_f.close()

    notmuch_config_folder = email_archive_folder + b'/_notmuch_config'
    cprint("starting alot",)
    os.system(b' '.join([b'alot', b'--version']))
    move_terminal_text_up_one_page()        # so alot does not overwrite the last messages on the terminal
    alot_p = os.system(b' '.join([b'alot', b'-C', b'256', b'--debug-level=debug', b'--logfile=/dev/shm/__alot_log', b'--notmuch-config', notmuch_config_folder + b'/.notmuch_config', b'--mailindex-path', email_archive_folder + b'/_Maildirs', b'-c', b'/dev/shm/__alot_config_' + email_address]))


def load_ssh_key():
    cprint("load_ssh_key(%s)" % email_address)
    if b'gmail' in email_address:
        return

    ssh_key = b'/home/user/.ssh/id_rsa__' + email_address   #todo use ~/.gpgmda/config

    loaded_ssh_keys_p = subprocess.Popen([b'ssh-add', b'-l'], stdout=subprocess.PIPE)
    loaded_ssh_keys_p_output = loaded_ssh_keys_p.communicate()[0].strip()
    loaded_ssh_key_list = loaded_ssh_keys_p_output.split(b'\n')

    cprint("ssh-add -l output:")
    for line in loaded_ssh_key_list:
        cprint(line)

    cprint("looking for key:", ssh_key)
    found_key = 0
    for key in loaded_ssh_key_list:
        if ssh_key in key:
            found_key = 1
            break

    if found_key != 1:
        ssh_add_p = subprocess.Popen([b'ssh-add', ssh_key])
        ssh_add_p_output = ssh_add_p.communicate()
        if ssh_add_p.returncode != 0:
            cprint("something went wrong adding the ssh_key, exiting")
            os._exit(1)


def short_random_string():
    command = [b"gpg2", b"--gen-random", b"--armor", b"1", b"100"]
    cmd_proc = subprocess.Popen(command, stdout=subprocess.PIPE, shell=False)
    cmd_output = cmd_proc.stdout.read().strip() #get rid of newline
    return cmd_output


def warm_up_gpg():
    # due to https://bugs.g10code.com/gnupg/issue1190 first get gpg-agent warmed up by decrypting a test message.
    decrypt_test = 0

    while decrypt_test != 1:
        cprint("generating gpg test string")
        test_string = short_random_string()
        cprint("warm_up_gpg test_string:", test_string)

        command = "gpg --yes --trust-model always --throw-keyids --encrypt -o - | gpg --decrypt"
        gpg_cmd_proc = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        cprint("writing test_string to gpg_cmd_proc and reading output")
        gpg_cmd_proc_output_stdout, gpg_cmd_proc_output_stderr = gpg_cmd_proc.communicate(test_string)
        cprint("gpg_cmd_proct_output_stdout:")
        gpg_cmd_proc_output_stdout_decoded = gpg_cmd_proc_output_stdout.decode('utf-8')
        for line in gpg_cmd_proc_output_stdout_decoded.split('\n'):
            cprint("STDOUT:", line)

        cprint("gpg_cmd_proc_output_stderr:")
        gpg_cmd_proc_output_stderr_decoded = gpg_cmd_proc_output_stderr.decode('utf-8')
        for line in gpg_cmd_proc_output_stderr_decoded.split('\n'):
            cprint("STDERR:", line)

        cprint("gpg_cmd_proc.returncode:", gpg_cmd_proc.returncode)

        if gpg_cmd_proc.returncode != 0:
            cprint("warm_up_gpg did not return 0, exiting")
            os._exit(1)

        if not test_string in gpg_cmd_proc_output_stdout:
            cprint("test_string:", test_string, "is not in gpg_cmd_proc_output_stdout:", gpg_cmd_proc_output_stdout, "Exiting.")
            os._exit(1)
        else:
            cprint("found test string in gpg_cmd_proc_output_stdout, gpg is working")
            decrypt_test = 1

    return True


def get_maildir_file_counts():
    files_in_gpgmaildir = count_files(gpgmaildir)
    files_in_maildir = count_files(maildir)
    return {'files_in_gpgmaildir':files_in_gpgmaildir, "files_in_maildir":files_in_maildir}


def parse_rsync_log_to_list():
    rsync_log = b'/dev/shm/.gpgmda_rsync_last_new_mail_' + email_address
    with open(rsync_log, 'rb') as fh:
        rsync_log = fh.readlines()

    full_path_list = []
    for line in rsync_log:
        line = line.strip() #remove newlines
        if b'exists' not in line:
            if b'gpgMaildir' in line:
                if line.startswith(b'>f'):
                    new_gpgmda_file_path = gpgMaildir_archive_folder + b'/' + line.split(b' ')[1]
                    print("new_gpgmda_file_path:", new_gpgmda_file_path)
                    full_path_list.append(new_gpgmda_file_path)

    return full_path_list


def decrypt_list_of_messages(message_list):
    message_list = filter(None, message_list)   #remove empty items
    process_count = cpu_count()
    p = Pool(process_count)
    cprint("message_list:", message_list)
    for message in message_list:    #useful for debugging
       decrypt_message(message)


def decrypt_message(gpgfile, stdout=False):
    if not isinstance(gpgfile, bytes):
        cprint("decrypt_message() takes the gpgfile as bytes")
        os._exit(1)
    cprint("\ndecrypt_msg() gpgfile:", gpgfile)
    if b'@' not in email_address:
        cprint("Invalid email address:", email_address,", exiting.")
        os._exit(1)

    if not file_exists(gpgfile):
        cprint(gpgfile, "No such file or directory. Exiting.")
        os._exit(1)

    if is_zero_length_file(gpgfile):
        cprint("FOUND ZERO LENGTH FILE, EXITING. CHECK THE MAILSERVER LOGS (and manually delete it):", gpgfile)
        os._exit(1)

    gpgfile_name = os.path.basename(gpgfile)
    cprint("\ngpgfile_name:", gpgfile_name)

    gpgfile_folder_path = os.path.dirname(gpgfile)
    cprint("gpgfile_folder_path:", gpgfile_folder_path)

    maildir_subfolder = os.path.basename(gpgfile_folder_path)
    cprint("maildir_subfolder:", maildir_subfolder)

    if not folder_exists(maildir):
        cprint("maildir:", maildir, "does not exist. Exiting.")
        os._exit(1)

    file_previously_decrypted = 0

    glob_pattern = maildir + b'/' + maildir_subfolder + b'/*.' + gpgfile_name
    cprint("glob_pattern:", glob_pattern)

    result = glob.glob(glob_pattern)
    
    if len(result) > 1:
        cprint("ERROR: This shouldnt happen. More than one result was returned for glob_pattern:", glob_pattern, ": ", result)
        os._exit(1)

    if stdout == False:
        if len(result) == 1:
            result = result[0]
            cprint("skipping existing file:", result)
            return True

    cprint("decrypting:", gpgfile)

    if stdout == True:
#       command = "gpg2 -o - --decrypt " + gpgfile + " | tar --transform=s/$/." + gpgfile_name + "/ -xvf -" # hides the tar header
        command = b"gpg2 -o - --decrypt " + gpgfile
        cprint("decrypt_msg() command:", command)
        return_code = os.system(command)
        cprint("return_code:", return_code)

    else:
        gpg_command = [b"gpg2", b"-o", b"-", b"--decrypt", gpgfile]
        tar_command = [b"tar", b"--transform=s/$/." + gpgfile_name + b"/", b"-C", maildir + b'/' + maildir_subfolder, b"-xvf", b"-"]

        gpg_cmd_proc = subprocess.Popen(gpg_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False)
        cprint("executing gpg_command:", gpg_command)
        gpg_cmd_proc_output_stdout, gpg_cmd_proc_output_stderr = gpg_cmd_proc.communicate()

        if debug:
            cprint("gpg_cmd_proc_output_stdout:")
            gpg_cmd_proc_output_stdout_decoded = gpg_cmd_proc_output_stdout.decode('utf-8')
            for line in gpg_cmd_proc_output_stdout_decoded.split('\n'):
                cprint("STDOUT:", line)

        cprint("gpg_cmd_proc_output_stderr:")
        gpg_cmd_proc_output_stderr_decoded = gpg_cmd_proc_output_stderr.decode('utf-8')
        for line in gpg_cmd_proc_output_stderr_decoded.split('\n'):
            cprint("STDERR:", line)

        cprint("gpg_cmd_proc.returncode:", gpg_cmd_proc.returncode)

        if gpg_cmd_proc.returncode != 0:
            cprint("gpg2 did not return 0")
            return False

        if len(gpg_cmd_proc_output_stdout) > 0:
            tar_cmd_proc = subprocess.Popen(tar_command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False)
            cprint("executing tar_command:", tar_command)
            tar_cmd_proc_output_stdout, tar_cmd_proc_output_stderr = tar_cmd_proc.communicate(gpg_cmd_proc_output_stdout)
            cprint("tar_cmd_proc_output_stdout:")
            tar_cmd_proc_output_stdout_decoded = tar_cmd_proc_output_stdout.decode('utf-8')
            for line in tar_cmd_proc_output_stdout_decoded.split('\n'):
                cprint("STDOUT:", line)

            cprint("tar_cmd_proc_output_stderr:")
            tar_cmd_proc_output_stderr_decoded = tar_cmd_proc_output_stderr.decode('utf-8')
            for line in tar_cmd_proc_output_stderr_decoded.split('\n'):
                cprint("STDERR:", line)

            cprint("tar_cmd_proc.returncode:", tar_cmd_proc.returncode)

            if tar_cmd_proc.returncode != 0:
                cprint("tar did not return 0")
                return False
        else:
            cprint("gpg did not produce any stdout, tar skipped file:", gpgfile)
            cprint("looking into:", gpgfile, "further...")
            os.system(b'/bin/ls -al ' + gpgfile)
            stats = os.stat(gpgfile)
            if stats.st_size <= 1141:
                cprint("this is likely an empty gpg encrypted file")

            delete_message_answer = input("Would you like to move this message locally to the ~/.gpgmda/badmail folder and delete it off the server? (yes/no): ")

            if delete_message_answer.lower() == "yes":
                badmail_path = os.path.expanduser(b'~/.gpgmda/badmail')
                print("type(badmail_path):", type(badmail_path))
                os.makedirs(os.path.expanduser(badmail_path), exist_ok=True)
                cprint("Processing files for local move and delete gpgfile:", gpgfile)

                os.path.sep = b'/'      #py3: paths _are_ bytes. glob.glob(b'/home') does it right
                os.path.altsep = b'/'
  
                shutil.move(gpgfile, badmail_path)

                random_id = gpgfile.split(b'/')[-1]

                if maildir_subfolder == b".sent":
                    target_file = b"/home/sentuser/gpgMaildir/new/" + random_id
                    command = b"ssh root@v6y.net rm -v " + target_file
                    cprint(command)
                    os.system(command)

                elif maildir_subfolder == b"new":
                    target_file = b"/home/user/gpgMaildir/new/" + random_id
                    command = b"ssh root@v6y.net rm -v " + target_file    #todo use ~/.gpgmda/config
                    cprint(command)
                    os.system(command)

                else:
                    cprint("unknown exception, exiting")
                    os._exit(1)


            return False


    return True



def gpgmaildir_to_maildir():
    # todo add locking
    cprint("gpgmda_to_maildir using gpgMaildir_archive_folder:", gpgMaildir_archive_folder)
    cprint("Checking for default-recipient in ~/.gnupg/gpg.conf")
    command = "grep \"^default-recipient\" ~/.gnupg/gpg.conf"
    grep_exit_code = os.system(command)
    if grep_exit_code != 0:
        cprint("error: default-recipient is not defined in ~/.gnupg/gpg.conf. Exiting.")
        os._exit(1)

    rsync_last_new_mail_file = b'/dev/shm/.gpgmda_rsync_last_new_mail_' + email_address
    cprint("checking to see if", rsync_last_new_mail_file, "exists and is greater than 0 bytes")

    rsync_files_transferred = 0
    if not is_zero_length_file(rsync_last_new_mail_file):
        with open(rsync_last_new_mail_file, 'r') as fh:
            for line in fh.readlines():
                if 'Number of regular files transferred:' in line:
                    cprint(line)
                    rsync_files_transferred = line.split(':')[1].strip()
                    cprint("rsync_files_transferred:", rsync_files_transferred)
                    break
        if rsync_files_transferred == 0:
            cprint("rsync transferred 0 files, skipping decrypt")
            
        else:
            rsync_list = parse_rsync_log_to_list()
            cprint("rsync_list:", rsync_list)
            decrypt_list_of_messages(rsync_list)

    else:
        cprint(rsync_last_new_mail_file, "does not exist or is 0 bytes")

    cprint("\nchecking if the message counts in the maildir and the gpgmaildir match")
    maildir_counts_dict = get_maildir_file_counts()
    cprint("maildir_counts_dict:", maildir_counts_dict)

    if maildir_counts_dict['files_in_gpgmaildir'] > maildir_counts_dict['files_in_maildir']:
        cprint("files_in_gpgmaildir > files_in_maildir:", maildir_counts_dict['files_in_gpgmaildir'], '>', maildir_counts_dict['files_in_maildir'])
        cprint("locating un-decrypted files")
        files_in_gpgmaildir = list_files(gpgmaildir)
        files_in_maildir = list_files(maildir)
        cprint("len(files_in_gpgmaildir):", len(files_in_gpgmaildir))
        cprint("len(files_in_maildir):", len(files_in_maildir))
        full_maildir_string = b"\n".join(files_in_maildir)

        for file in files_in_gpgmaildir:
            subfolder = file.split(b'/')[-2]
            hash = file.split(b'/')[-1]
            if hash not in full_maildir_string:
                print("\n\nfound file that has not been decrypted yet:", file)
                decrypt_message(file, stdout=False)
    return


def search_list_of_strings_for_substring(list, substring):
    item_found = ''
    for item in list:
        try:
            if substring in item:
                item_found = item
                break   
        except TypeError:
            pass

    return item_found


def update_notmuch_db():
    run_notmuch("update_notmuch_db")


def update_notmuch_address_db():
    run_notmuch("update_address_db")


def update_notmuch_address_db_build():
    run_notmuch("build_address_db")


def query_notmuch(query):
    run_notmuch("query_notmuch", query)


def query_notmuch_address_db(query):
    run_notmuch("query_address_db", query)


def check_noupdate_list():
    noupdate_list = open(gpgmda_program_folder + b"/.noupdate", 'r').readlines() #todo move config to ~/.gpgmda
    for item in noupdate_list:
        if args.email_address in item:
            cprint(args.email_address + " is listed in .noupdate, exiting")
            os._exit(1)


def main():
    global options, args

    global email_address
    email_address = bytes(args.email_address, encoding='UTF8')

    global gpgmda_program_folder
    gpgmda_program_folder = os.path.dirname(bytes(os.path.realpath(__file__), encoding='UTF8'))

    global email_archive_folder
    email_archive_folder = b"/home/user/__email_folders"

    check_or_create_folder(email_archive_folder)

    global gpgMaildir_archive_folder
    gpgMaildir_archive_folder = email_archive_folder + b"/_gpgMaildirs/" + email_address
    check_or_create_folder(gpgMaildir_archive_folder)

    global gpgmaildir
    gpgmaildir = gpgMaildir_archive_folder + b"/gpgMaildir"
    check_or_create_folder(gpgmaildir)

    Maildir_archive_folder = email_archive_folder + b"/_Maildirs/" + email_address
    check_or_create_folder(Maildir_archive_folder)

    global maildir
    maildir = Maildir_archive_folder + b"/Maildir"
    check_or_create_folder(maildir + b"/new")
    check_or_create_folder(maildir + b"/cur")
    check_or_create_folder(maildir + b"/.sent")

    email_archive_type = "gpgMaildir"       # fixme: support getmail

    if args.download:
        check_noupdate_list()
            
        if email_archive_type == "gpgMaildir":
            check_or_create_folder(gpgMaildir_archive_folder)
            warm_up_gpg()
            rsync_mail()

        else:
            cprint("Unsupported email_archive_type:", email_archive_type, "Exiting.")
            os._exit(1)

    if args.decrypt:
        check_noupdate_list()

        if email_archive_type == "gpgMaildir":
            check_or_create_folder(gpgMaildir_archive_folder)
            warm_up_gpg()
            gpgmaildir_to_maildir()

        else:
            cprint("Unsupported email_archive_type:", email_archive_type, "Exiting.")
            os._exit(1)

    if args.update_notmuch:
        check_noupdate_list()

        if email_archive_type == "gpgMaildir":
            check_or_create_folder(gpgMaildir_archive_folder)
            warm_up_gpg()

        elif email_archive_type == "getmail":
            cprint('gpgmda_program_folder/getmail_gmail "${email_address}" || exit 1')
            cprint("todo, call /getmail_gmail ${email_address}")

        else:
            cprint("unknown folder type", email_archive_type, ", exiting")

        update_notmuch_db()
        update_notmuch_address_db()

    if args.read:

        load_ssh_key()     # so mail can be sent without having to unlock the key
        make_notmuch_config()
        start_alot()

    if args.notmuch_query:
        query_notmuch(args.multi)

    if args.address_db_build:
        update_notmuch_address_db_build()

    if args.address_query:
        query = args.address_query
        query_notmuch_address_db(query)


# http://stackoverflow.com/questions/3853722/python-argparse-how-to-insert-newline-in-the-help-text
class SmartFormatter(argparse.HelpFormatter):
    def _split_lines(self, text, width):
        # this is the RawTextHelpFormatter._split_lines
        if text.startswith('R|'):
            return text[2:].splitlines()
        return argparse.HelpFormatter._split_lines(self, text, width)


if __name__ == '__main__':

    try:
        start_time = time.time()
        parser = argparse.ArgumentParser(formatter_class=SmartFormatter)
        parser.add_argument("email_address", help='R|email address')

        parser.add_argument("--verbose", help="R|enable debug output", action="store_true", default=False)
        parser.add_argument("--read", help="R|read mail without checking for new mail", action="store_true", default=False)

        parser.add_argument("--update_notmuch", help="R|update notmuch with new mail from (normal, unencrypted) maildir", action="store_true", default=False)
        parser.add_argument("--download",       help="R|rsync new mail to encrypted maildir", action="store_true", default=False)
        parser.add_argument("--decrypt",        help="R|decrypt new mail in encrypted maildir to unencrypted maildir", action="store_true", default=False)
        parser.add_argument("--address_query",  help="R|search for address string", type=str)
        parser.add_argument("--address_db_build", help="R|build address database for use with --address_query", action="store_true", default=False)
        parser.add_argument("--notmuch_query",  help="R|execute arbitrary notmuch query", type=str)

        args = parser.parse_args()

        if args.verbose:
            cprint(time.asctime())

        main_result = main()
        if debug: cprint("main_result:", main_result)

        if args.verbose:
            cprint(time.asctime())
            cprint('TOTAL TIME IN MINUTES:',)
            cprint((time.time() - start_time) / 60.0)

    except KeyboardInterrupt as e:
        raise e

    except SystemExit as e:
        raise e

    except Exception as e:
        cprint('ERROR, UNEXPECTED EXCEPTION')
        cprint(str(e))
        traceback.print_exc()
        os._exit(1)
