#!/usr/bin/env python3.3
# -*- coding: utf8 -*-

from __future__ import print_function
from __future__ import unicode_literals

# todo: locking to prevent multiple instances of mail_update

import sys
import os
import traceback
import optparse
import time
import subprocess
import shutil
import glob
from os.path import exists

from multiprocessing import Process     #https://docs.python.org/3/library/multiprocessing.html
from multiprocessing import Queue
from multiprocessing import Pool
from multiprocessing import cpu_count

global debug
debug = False


def cprint(*args, **kwargs):
    caller = sys._getframe(1).f_code.co_name
    print(str("%.5f" % time.time()), os.getpid(), '{0: <39}'.format(caller+'()'), *args, file=sys.stderr, **kwargs)


def is_zero_length_file(fpath):
    if os.path.isfile(fpath) and os.path.getsize(fpath) == 0:
        return True
    return False


def count_files(folder):
    total = 0
    for root, dirs, files in os.walk(folder):
        total += len(files)
    return total

def list_files(folder):
    all_files = []
    total = 0
    for root, dirs, files in os.walk(folder):
        for file in files:
            relative_file_path = root + b'/' + file
#            print(relative_file_path)
            all_files.append(relative_file_path)
    return set(all_files)

def folder_exists(path):
    cprint("folder_exists():", path)
    if os.path.isdir(path): #unlike os.path.exists(False), os.path.isdir(False) returns False so no need to call path_exists() first.
        return True
    return False

def create_folder(folder):
    try:
        os.makedirs(folder)
        return True
    except Exception as e:
        cprint(e)
        cprint("Something went wrong making the folder:", folder, "Exiting.")
        os._exit(1)


def check_or_create_folder(folder):
    if not os.path.isdir(folder):
        make_folder_answer = input("The folder " + folder + " does not exist. This is not normal. Type yes to create it and continue, otherwise exiting here.: ")
        if make_folder_answer.lower() != "yes":
            cprint("Exiting before mkdir.")
            os._exit(1)
        else:
            create_folder(folder)
            return True


def check_for_notmuch_database():
    notmuch_database_folder = email_archive_folder + b"/_Maildirs/.notmuch/xapian"
    if not os.path.isdir(notmuch_database_folder):
        cprint('''Error: notmuch has not created the xapian database yet. Run \"mail_update user@domain.com --update\" first. Exiting.''')
        os._exit(1)


def rsync_mail():
    load_ssh_key()

    rsync_p = subprocess.Popen([b'rsync', b'--ignore-existing', b'--size-only', b'-t', b'--whole-file', b'-L', b'-c', b'--stats', b'-i', b'-r', b'-vv', email_address + b':gpgMaildir', gpgMaildir_archive_folder + b'/'], stdout=subprocess.PIPE)
    rsync_p_output = rsync_p.communicate()
    for line in rsync_p_output[0].split(b'\n'):
#       cprint(line.decode('utf-8'))
        cprint(line)

    cprint("rsync_p.returncode:", rsync_p.returncode)
    if rsync_p.returncode != 0:
        cprint("rsync did not return 0, exiting")
        os._exit(1)

    with open(b"/dev/shm/.gpgmda_rsync_last_new_mail_" + email_address, 'wb') as rsync_logfile_handle:
        rsync_logfile_handle.write(rsync_p_output[0])


def run_notmuch(mode, query=b"", debug=False):
    if debug: cprint("run_notmuch():", mode)
    if not isinstance(query, bytes):
        query = bytes(query, encoding='UTF8')

    notmuch_config_folder = email_archive_folder + b"/_notmuch_config"
    check_or_create_folder(notmuch_config_folder)

    notmuch_config_file = notmuch_config_folder + b"/.notmuch_config"
    make_notmuch_config()

    if mode == "update_notmuch_db":

        current_env = os.environ.copy()
        current_env["NOTMUCH_CONFIG"] = notmuch_config_file
        notmuch_p = subprocess.Popen([b'notmuch', b'new'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False, env=current_env)
        cprint(notmuch_p.args)
        notmuch_p_output = notmuch_p.communicate()

        cprint("notmuch_p_output:")
        cprint(notmuch_p_output)

        cprint("notmuch_p_output[0]:")
        for line in notmuch_p_output[0].split(b'\n'):
            cprint(line) 
#           cprint(line.decode('utf-8'))

        cprint("notmuch_p_output[1]:")
        for line in notmuch_p_output[1].split(b'\n'):
#           line = line.decode('utf-8')
            cprint("line:", line)
            if b"Note: Ignoring non-mail file:" in line:
                non_mail_file = line.split(b" ")[-1]
                cprint("found file that gmime does not like:", non_mail_file)
                random_id = non_mail_file[-40:]
                cprint("random_id:", random_id)
                maildir_subdir = non_mail_file.split(b'/')[-2]
                cprint("maildir_subdir:", maildir_subdir)
                encrypted_file = gpgmaildir + b'/' + maildir_subdir + b'/' + random_id
                cprint("encrypted_file:", encrypted_file)
                cprint("head -c 500:")
                command = b"head -c 500 " + non_mail_file
                os.system(command)
                cprint("running nano")
                command = b"nano " + non_mail_file
                os.system(command)

                delete_message_answer = input("Would you like to move this message locally to the ~/.gpgmda/non-mail folder and delete it on the server? (yes/no/skipall): ")

                if delete_message_answer.lower() == "skipall":
                    break

                if delete_message_answer.lower() == "yes":
                    non_mail_path = b'~/.gpgmda/non-mail'
                    os.makedirs(os.path.expanduser(non_mail_path), exist_ok=True)

                    cprint("Processing files for local move and delete:")

                    cprint(non_mail_file)
                    shutil.move(non_mail_file, os.path.expanduser(non_mail_path))

                    cprint(encrypted_file)
                    shutil.move(encrypted_file, os.path.expanduser(non_mail_path))

                    if maildir_subdir == b".sent":
                        target_file = b"/home/sentuser/gpgMaildir/new/" + random_id
                        command = b"ssh root@v6y.net rm -v " + target_file
                        cprint(command)
                        os.system(command)

                    elif maildir_subdir == b"new":
                        target_file = b"/home/user/gpgMaildir/new/" + random_id
                        command = b"ssh root@v6y.net rm -v " + target_file    #todo use ~/.gpgmda/config
                        cprint(command)
                        os.system(command)

                    else:
                        cprint("unknown exception, exiting")
                        os._exit(1)

        cprint("notmuch_p.returncode:", notmuch_p.returncode)
        if notmuch_p.returncode != 0:
            cprint("notmuch new did not return 0, exiting")
            os._exit(1)

    elif mode == "query_notmuch":
        check_for_notmuch_database()
        command = b"NOTMUCH_CONFIG=" + notmuch_config_file + b" notmuch " + query
        cprint("command:", command)
        return_code = os.system(command)
        if return_code != 0:
            cprint("\"notmuch " + query + "\" returned nonzero, exiting")
            os._exit(1)

    elif mode == "query_address_db":
        check_for_notmuch_database()
        command = b"XDG_CONFIG_HOME=" + notmuch_config_folder + b" NOTMUCH_CONFIG=" + notmuch_config_file + b" " + gpgmda_program_folder + b"/nottoomuch-addresses.sh " + query
        return_code = os.system(command)
        if return_code != 0:
            cprint("\"nottoomuch-addresses.sh\" returned nonzero, exiting")
            os._exit(1)

    elif mode == "build_address_db":
        check_for_notmuch_database()
        command = b"XDG_CONFIG_HOME=" + notmuch_config_folder + b" NOTMUCH_CONFIG=" + notmuch_config_file + b" " + gpgmda_program_folder + b"/nottoomuch-addresses.sh --update --rebuild"
        return_code = os.system(command)
        if return_code != 0:
            cprint("\"nottoomuch-addresses.sh\" returned nonzero, exiting")
            os._exit(1)

    elif mode == "update_address_db":
        check_for_notmuch_database()
        command = b"XDG_CONFIG_HOME=" + notmuch_config_folder + b" NOTMUCH_CONFIG=" + notmuch_config_file + b" " + gpgmda_program_folder + b"/nottoomuch-addresses.sh --update"
        return_code = os.system(command)
        if return_code != 0:
            cprint("\"nottoomuch-addresses.sh\" returned nonzero, exiting")
            os._exit(1)

    else:
        cprint("invalid mode", mode, "exiting.")
        os._exit(1)


def make_notmuch_config():
    username = email_address.split(b"@")[0]

    notmuch_config = b"""
[database]
path = """ + email_archive_folder + b"""/_Maildirs

[user]
name = """ + username + b"""
primary_email=""" + email_address + b"""

[new]
tags = unread;inbox;

[maildir]
synchronize_flags = false
"""
    notmuch_config_folder = email_archive_folder + b"/_notmuch_config"
    check_or_create_folder(notmuch_config_folder)
    notmuch_config_file_location = notmuch_config_folder + b"/.notmuch_config"
    if debug: cprint("writing notmuch config to:", notmuch_config_file_location)
    notmuch_config_file_handle = open(notmuch_config_file_location, "wb")
    notmuch_config_file_handle.write(notmuch_config)
    notmuch_config_file_handle.close()


def move_terminal_text_up_one_page():
    cprint("moving terminal text up one page")
    tput_p = subprocess.Popen(['tput', 'lines'], stdout=subprocess.PIPE)
    tput_p_output = tput_p.communicate()
    tput_p_output = tput_p_output[0].decode('utf8').strip()

    for line in range(int(tput_p_output)):
        print('', file=sys.stderr)


def start_alot():
    check_for_notmuch_database()
    alot_config = subprocess.Popen([gpgmda_program_folder + b"/make_alot_config", email_address], stdout=subprocess.PIPE).communicate()
    alot_theme = subprocess.Popen([gpgmda_program_folder + b"/make_alot_theme"], stdout=subprocess.PIPE).communicate()

    alot_config_f = open(b'/dev/shm/__alot_config_' + email_address, 'wb')
    alot_theme_f = open(b'/dev/shm/__alot_theme_' + email_address, 'wb')

    alot_config_f.write(alot_config[0])
    alot_theme_f.write(alot_theme[0])

    alot_config_f.close()
    alot_theme_f.close()

    notmuch_config_folder = email_archive_folder + b'/_notmuch_config'
    cprint("starting alot",)
    os.system(b' '.join([b'alot', b'--version']))
    move_terminal_text_up_one_page()        # so alot does not overwrite the last messages on the terminal
    alot_p = os.system(b' '.join([b'alot', b'-C', b'256', b'--debug-level=debug', b'--logfile=/dev/shm/__alot_log', b'--notmuch-config', notmuch_config_folder + b'/.notmuch_config', b'--mailindex-path', email_archive_folder + b'/_Maildirs', b'-c', b'/dev/shm/__alot_config_' + email_address]))


def load_ssh_key():
    cprint("load_ssh_key(%s)" % email_address)
    if b'gmail' in email_address:
        return

    ssh_key = b'/home/user/.ssh/id_rsa__' + email_address   #todo use ~/.gpgmda/config

    loaded_ssh_keys_p = subprocess.Popen([b'ssh-add', b'-l'], stdout=subprocess.PIPE)
    loaded_ssh_keys_p_output = loaded_ssh_keys_p.communicate()[0].strip()
    loaded_ssh_key_list = loaded_ssh_keys_p_output.split(b'\n')

    cprint("ssh-add -l output:")
    for line in loaded_ssh_key_list:
        cprint(line)

    cprint("looking for key:", ssh_key)
    found_key = 0
    for key in loaded_ssh_key_list:
        if ssh_key in key:
            found_key = 1
            break

    if found_key != 1:
        ssh_add_p = subprocess.Popen([b'ssh-add', ssh_key])
        ssh_add_p_output = ssh_add_p.communicate()
        if ssh_add_p.returncode != 0:
            cprint("something went wrong adding the ssh_key, exiting")
            os._exit(1)


def short_random_string():
    command = [b"gpg2", b"--gen-random", b"--armor", b"1", b"100"]
    cmd_proc = subprocess.Popen(command, stdout=subprocess.PIPE, shell=False)
    cmd_output = cmd_proc.stdout.read().strip() #get rid of newline
    return cmd_output


def warm_up_gpg():
    # due to https://bugs.g10code.com/gnupg/issue1190 first get gpg-agent warmed up by decrypting a test message.
    decrypt_test = 0

    while decrypt_test != 1:
        cprint("generating gpg test string")
        test_string = short_random_string()
        cprint("warm_up_gpg test_string:", test_string)

        command = "gpg --yes --trust-model always --throw-keyids --encrypt -o - | gpg --decrypt"
        gpg_cmd_proc = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        cprint("writing test_string to gpg_cmd_proc and reading output")
        gpg_cmd_proc_output_stdout, gpg_cmd_proc_output_stderr = gpg_cmd_proc.communicate(test_string)
        cprint("gpg_cmd_proct_output_stdout:")
        gpg_cmd_proc_output_stdout_decoded = gpg_cmd_proc_output_stdout.decode('utf-8')
        for line in gpg_cmd_proc_output_stdout_decoded.split('\n'):
            cprint("STDOUT:", line)

        cprint("gpg_cmd_proc_output_stderr:")
        gpg_cmd_proc_output_stderr_decoded = gpg_cmd_proc_output_stderr.decode('utf-8')
        for line in gpg_cmd_proc_output_stderr_decoded.split('\n'):
            cprint("STDERR:", line)

        cprint("gpg_cmd_proc.returncode:", gpg_cmd_proc.returncode)

        if gpg_cmd_proc.returncode != 0:
            cprint("warm_up_gpg did not return 0, exiting")
            os._exit(1)

        if not test_string in gpg_cmd_proc_output_stdout:
            cprint("test_string:", test_string, "is not in gpg_cmd_proc_output_stdout:", gpg_cmd_proc_output_stdout, "Exiting.")
            os._exit(1)
        else:
            cprint("found test string in gpg_cmd_proc_output_stdout, gpg is working")
            decrypt_test = 1

    return True


def get_maildir_file_counts():
    files_in_gpgmaildir = count_files(gpgmaildir)
    files_in_maildir = count_files(maildir)
    return {'files_in_gpgmaildir':files_in_gpgmaildir, "files_in_maildir":files_in_maildir}


def parse_rsync_log_to_bytes():
    command = b"cat /dev/shm/.gpgmda_rsync_last_new_mail_" + email_address + b"| grep -v exists | grep gpgMaildir | grep '^>f' | cut -d ' ' -f 2 | cut -d '/' -f 2-"
    cmd_proc = subprocess.Popen(command, stdout=subprocess.PIPE, shell=True)
    cmd_output = cmd_proc.stdout.read()
    cprint("parse_rsync_log_to_bytes() cmd_output:", cmd_output)
    return cmd_output


def parse_rsync_log_to_list():
    rsync_log_bytes = parse_rsync_log_to_bytes().strip()
    rsync_log_bytes_list = rsync_log_bytes.split(b'\n')
    return rsync_log_bytes_list


def decrypt_list_of_messages(message_list):
#    message_list = [x for x in message_list if x]   #remove empty items
    message_list = filter(None, message_list)   #remove empty items
    process_count = cpu_count()
    p = Pool(process_count)
    cprint("message_list:", message_list)
    for message in message_list:    #useful for debugging
       decrypt_message(message)

#    for output in p.imap_unordered(decrypt_message, message_list):
#        print(output)

def decrypt_message(gpgfile, stdout=False):
    if not isinstance(gpgfile, bytes):
        cprint("decrypt_message() takes the gpgfile as bytes")
        os._exit(1)
    cprint("\ndecrypt_msg() gpgfile:", gpgfile)
    if b'@' not in email_address:
        cprint("Invalid email address:", email_address,", exiting.")
        os._exit(1)

    if is_zero_length_file(gpgfile):
        cprint("FOUND ZERO LENGTH FILE, EXITING. CHECK THE MAILSERVER LOGS:", gpgfile)
        with open(zero_length_file_log, 'a') as fh:
            fh.write(gpgfile + '\n')
            os._exit(1)

    gpgfile_name = os.path.basename(gpgfile)
    cprint("\ngpgfile_name:", gpgfile_name)

    gpgfile_folder_path = os.path.dirname(gpgfile)
    cprint("gpgfile_folder_path:", gpgfile_folder_path)

    gpgfile_subfolder = os.path.basename(gpgfile_folder_path)
    cprint("gpgfile_subfolder:", gpgfile_subfolder)

    if not folder_exists(maildir):
        cprint("maildir:", maildir, "does not exist. Exiting.")
        os._exit(1)

#   mkdir(badmail_folder) #todo old symlink to badmail 
#   ln -s "${gpgfile}" ~/.gpgmda/badmail/"${gpgfile_name}" || echo "unable to symlink ${gpgfile} to badmail"
#   gpg2 -o - --decrypt "${gpgfile}" | tar --transform="s/$/.${gpgfile_name}/" -C  "${maildir_folder}/${gpgfile_subfolder}" -xvf -
#   rm ~/.gpgmda/badmail/"${gpgfile_name}" || echo "unable to remove symlink ${gpgfile} from badmail"

    file_previously_decrypted = 0

    glob_pattern = maildir + b'/' + gpgfile_subfolder + b'/*.' + gpgfile_name
    cprint("glob_pattern:", glob_pattern)

    result = glob.glob(glob_pattern)
    
    if len(result) > 1:
        cprint("ERROR: This shouldnt happen. More than one result was returned for glob_pattern:", glob_pattern, ": ", result)
        os._exit(1)

    if stdout == False:
        if len(result) == 1:
            result = result[0]
            cprint("skipping existing file:", result)
            return True

    cprint("decrypting:", gpgfile)

    if stdout == True:
#       command = "gpg2 -o - --decrypt " + gpgfile + " | tar --transform=s/$/." + gpgfile_name + "/ -xvf -"
        command = b"gpg2 -o - --decrypt " + gpgfile
        cprint("decrypt_msg() command:", command)
        return_code = os.system(command)
        cprint("return_code:", return_code)

    else:
        # command = b"gpg2 -o - --decrypt " + gpgfile + b" | tar --transform=s/$/." + gpgfile_name + b"/ -C " + maildir + b'/' + gpgfile_subfolder + b" -xvf -"
        gpg_command = [b"gpg2", b"-o", b"-", b"--decrypt", gpgfile]
        tar_command = [b"tar", b"--transform=s/$/." + gpgfile_name + b"/", b"-C", maildir + b'/' + gpgfile_subfolder, b"-xvf", b"-"]
#                      [b'tar', b'--transform=s/$/.fhSIy2P4-JqPpV-QdeyGRpAU6J0r+R700Fbe8-pN/', b'-C', b'/home/user/__email_folders/_Maildirs/user@v6y.net/Maildir/.sent', b'-xvf', b'-']

        gpg_cmd_proc = subprocess.Popen(gpg_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False)
        cprint("executing gpg_command:", gpg_command)
        gpg_cmd_proc_output_stdout, gpg_cmd_proc_output_stderr = gpg_cmd_proc.communicate()

        if debug:
            cprint("gpg_cmd_proc_output_stdout:")
            gpg_cmd_proc_output_stdout_decoded = gpg_cmd_proc_output_stdout.decode('utf-8')
            for line in gpg_cmd_proc_output_stdout_decoded.split('\n'):
                cprint("STDOUT:", line)

        cprint("gpg_cmd_proc_output_stderr:")
        gpg_cmd_proc_output_stderr_decoded = gpg_cmd_proc_output_stderr.decode('utf-8')
        for line in gpg_cmd_proc_output_stderr_decoded.split('\n'):
            cprint("STDERR:", line)

        cprint("gpg_cmd_proc.returncode:", gpg_cmd_proc.returncode)

        if gpg_cmd_proc.returncode != 0:
            cprint("gpg2 did not return 0")
            return False

 
        if len(gpg_cmd_proc_output_stdout) > 0:
            tar_cmd_proc = subprocess.Popen(tar_command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False)
            cprint("executing tar_command:", tar_command)
            tar_cmd_proc_output_stdout, tar_cmd_proc_output_stderr = tar_cmd_proc.communicate(gpg_cmd_proc_output_stdout)
            cprint("tar_cmd_proc_output_stdout:")
            tar_cmd_proc_output_stdout_decoded = tar_cmd_proc_output_stdout.decode('utf-8')
            for line in tar_cmd_proc_output_stdout_decoded.split('\n'):
                cprint("STDOUT:", line)

            cprint("tar_cmd_proc_output_stderr:")
            tar_cmd_proc_output_stderr_decoded = tar_cmd_proc_output_stderr.decode('utf-8')
            for line in tar_cmd_proc_output_stderr_decoded.split('\n'):
                cprint("STDERR:", line)

            cprint("tar_cmd_proc.returncode:", tar_cmd_proc.returncode)

            if tar_cmd_proc.returncode != 0:
                cprint("tar did not return 0")
                return False
        else:
            cprint("gpg did not produce any stdout, tar skipped on file:", gpgfile)
            cprint("looking into:", gpgfile, "further...")
            os.system(b'/bin/ls -al ' + gpgfile)
            stats = os.stat(gpgfile)
            if stats.st_size <= 1141:
                cprint("this is likely a empty gpg encrypted file")
            return False


    return True



def gpgmaildir_to_maildir():
    # todo add locking
    cprint("gpgmda_to_maildir using gpgMaildir_archive_folder:", gpgMaildir_archive_folder)
    cprint("Checking for default-recipient in ~/.gnupg/gpg.conf")
    command = "grep \"^default-recipient\" ~/.gnupg/gpg.conf"
    grep_exit_code = os.system(command)
    if grep_exit_code != 0:
        cprint("error: default-recipient is not defined in ~/.gnupg/gpg.conf. Exiting.")
        os._exit(1)

    rsync_last_new_mail_file = b'/dev/shm/.gpgmda_rsync_last_new_mail_' + email_address
    cprint("checking to see if", rsync_last_new_mail_file, "exists and is greater than 0 bytes")

    rsync_files_transferred = 0
    if not is_zero_length_file(rsync_last_new_mail_file):
        with open(rsync_last_new_mail_file, 'r') as fh:
            for line in fh.readlines():
                if 'Number of regular files transferred:' in line:
                    cprint(line)
                    rsync_files_transferred = line.split(':')[1].strip()
                    cprint("rsync_files_transferred:", rsync_files_transferred)
                    break
        if rsync_files_transferred == 0:
            cprint("rsync transferred 0 files, skipping decrypt")
            
        else:
            rsync_list = parse_rsync_log_to_list()
            cprint("rsync_list:", rsync_list)
            decrypt_list_of_messages(rsync_list)

    else:
        cprint(rsync_last_new_mail_file, "does not exist or is 0 bytes")


    cprint("\nchecking if the message counts in the maildir and the gpgmaildir match")
    maildir_counts_dict = get_maildir_file_counts()
    cprint("maildir_counts_dict:", maildir_counts_dict)

    if maildir_counts_dict['files_in_gpgmaildir'] > maildir_counts_dict['files_in_maildir']:
        cprint("files_in_gpgmaildir > files_in_maildir:", maildir_counts_dict['files_in_gpgmaildir'], '>', maildir_counts_dict['files_in_maildir'])
        cprint("locating un-decrypted files")
        files_in_gpgmaildir = list_files(gpgmaildir)
        files_in_maildir = list_files(maildir)
        cprint("len(files_in_gpgmaildir):", len(files_in_gpgmaildir))
        cprint("len(files_in_maildir):", len(files_in_maildir))
        full_maildir_string = b"\n".join(files_in_maildir)

        for file in files_in_gpgmaildir:
            subfolder = file.split(b'/')[-2]
            hash = file.split(b'/')[-1]
            if hash not in full_maildir_string:
                print("\n\nfound file that has not been decrypted yet:", file)
                decrypt_message(file, stdout=False)
           
    return


def search_list_of_strings_for_substring(list, substring):
    item_found = ''
    for item in list:
        try:
            if substring in item:
                item_found = item
                break   
        except TypeError:
            pass

    return item_found


def update_notmuch_db():
    run_notmuch("update_notmuch_db")

def update_notmuch_address_db():
    run_notmuch("update_address_db")

def update_notmuch_address_db_build():
    run_notmuch("build_address_db")

def query_notmuch(query):
    run_notmuch("query_notmuch", query)

def query_notmuch_address_db(query):
    run_notmuch("query_address_db", query)


def main():

    global options, args
#    cprint(options)

    global email_address
    email_address = bytes(args[0], encoding='UTF8')

    global gpgmda_program_folder
    gpgmda_program_folder = os.path.dirname(bytes(os.path.realpath(__file__), encoding='UTF8'))

    global email_archive_folder
    email_archive_folder = b"/home/user/__email_folders"

    check_or_create_folder(email_archive_folder)

    global gpgMaildir_archive_folder
    gpgMaildir_archive_folder = email_archive_folder + b"/_gpgMaildirs/" + email_address
    check_or_create_folder(gpgMaildir_archive_folder)

    global gpgmaildir
    gpgmaildir = gpgMaildir_archive_folder + b"/gpgMaildir"
    check_or_create_folder(gpgmaildir)

    Maildir_archive_folder = email_archive_folder + b"/_Maildirs/" + email_address
    check_or_create_folder(Maildir_archive_folder)

    global maildir
    maildir = Maildir_archive_folder + b"/Maildir"
    check_or_create_folder(maildir + b"/new")
    check_or_create_folder(maildir + b"/cur")
    check_or_create_folder(maildir + b"/.sent")

    email_archive_type = "gpgMaildir"       # fixme: support getmail

    if options.download:

        noupdate_list = open(gpgmda_program_folder + b"/.noupdate", 'r').readlines() #todo move config to ~/.gpgmda
        for item in noupdate_list:
            if args[0] in item:
                cprint(args[0] + " is listed in .noupdate, exiting")
                os._exit(1)
            
        if email_archive_type == "gpgMaildir":
            check_or_create_folder(gpgMaildir_archive_folder)
            warm_up_gpg()
            rsync_mail()

        else:
            cprint("Unsupported email_archive_type:", email_archive_type, "Exiting.")
            os._exit(1)


    if options.decrypt:

        noupdate_list = open(gpgmda_program_folder + b"/.noupdate", 'r').readlines() #todo move config to ~/.gpgmda
        for item in noupdate_list:
            if args[0] in item:
                cprint(args[0] + " is listed in .noupdate, exiting")
                os._exit(1)


        if email_archive_type == "gpgMaildir":
            check_or_create_folder(gpgMaildir_archive_folder)
            warm_up_gpg()
            gpgmaildir_to_maildir()

        else:
            cprint("Unsupported email_archive_type:", email_archive_type, "Exiting.")
            os._exit(1)


    if options.update_notmuch:

        noupdate_list = open(gpgmda_program_folder + b"/.noupdate", 'r').readlines() #todo move config to ~/.gpgmda
        for item in noupdate_list:
            if args[0] in item:
                cprint(args[0] + " is listed in .noupdate, exiting")
                os._exit(1)

        if email_archive_type == "gpgMaildir":
            check_or_create_folder(gpgMaildir_archive_folder)
            warm_up_gpg()

        elif email_archive_type == "getmail":
            cprint('gpgmda_program_folder/getmail_gmail "${email_address}" || exit 1')
            cprint("todo, call /getmail_gmail ${email_address}")

        else:
            cprint("unknown folder type", email_archive_type, ", exiting")

        update_notmuch_db()
        update_notmuch_address_db()

    if options.read:

        load_ssh_key()     # so mail can be sent without having to unlock the key
        make_notmuch_config()

#       update_notmuch_db()
#       update_notmuch_address_db()    #thses 2 are here until I get annoyed enough to fix the badmail problem

        start_alot()

    if options.multi:
        query_notmuch(options.multi)

    if options.address_db_build:
        update_notmuch_address_db_build()

    if options.address_query:
        query = args[1]
        query_notmuch_address_db(query)



if __name__ == '__main__':
    try:
        start_time = time.time()
        parser = optparse.OptionParser(formatter=optparse.TitledHelpFormatter(), usage=globals()['__doc__'], version='0.1')
        parser.add_option('-v', '--verbose', action='store_true', default=False, help='verbose output')
        parser.add_option('-r', '--read', action='store_true', default=False, help='read mail without checking for new mail')
        parser.add_option('-u', '--update_notmuch', action='store_true', default=False, help='update notmuch with new mail from (normal, unencrypted) maildir')
        parser.add_option('-d', '--download', action='store_true', default=False, help='rsync new mail to encrypted maildir')
        parser.add_option('-c', '--decrypt', action='store_true', default=False, help='decrypt new mail in encrypted maildir to unencrypted maildir')
        parser.add_option('-a', '--address_query', action='store_true', default=False, help='search for address string')
        parser.add_option('-b', '--address_db_build', action='store_true', default=False, help='build address database for use with --address_query')
        parser.add_option('-q', '--notmuch_query', dest='multi', action='store', help='notmuch arguments')
        (options, args) = parser.parse_args()
        if len(args) < 1:
            parser.error('missing argument')
        if options.verbose:
            cprint(time.asctime())

        exit_code = main()

        if exit_code is None:
            exit_code = 0
        if options.verbose:
            cprint(time.asctime())
            cprint('TOTAL TIME IN MINUTES:',)
            cprint((time.time() - start_time) / 60.0)
        sys.exit(exit_code)

    except KeyboardInterrupt as e:
        raise e

    except SystemExit as e:
        raise e

    except Exception as e:
        cprint('ERROR, UNEXPECTED EXCEPTION')
        cprint(str(e))
        traceback.print_exc()
        os._exit(1)
